{
  "id": "ckad-a-046",
  "title": "Advanced Resource Requests and Limits Tuning",
  "description": "Implement sophisticated resource management with complex ||resource requests|| and ||limits|| configurations. Create applications with different resource profiles: CPU-intensive, memory-intensive, and balanced workloads. Demonstrate ||Quality of Service|| (QoS) classes (Guaranteed, Burstable, BestEffort) and show how they affect pod scheduling and eviction. Include scenarios with ||resource quotas||, ||limit ranges||, and resource monitoring. Test resource constraint scenarios and show how applications behave under different resource pressure conditions.",
  "points": 14,
  "timeLimit": 28,
  "category": "Configuration",
  "tags": ["resource-requests", "resource-limits", "qos", "quality-of-service", "resource-management", "advanced"],
  "infrastructure": {
    "namespaces": ["resource-tuning"],
    "resources": ["Pod", "Deployment", "ResourceQuota", "LimitRange"],
    "prerequisites": ["Cluster with resource monitoring capabilities"]
  },
  "solution": {
    "steps": [
      "1. Create namespace and resource constraints:",
      "   kubectl create namespace resource-tuning",
      "   kubectl apply -f - <<EOF",
      "   apiVersion: v1",
      "   kind: LimitRange",
      "   metadata:",
      "     name: resource-limits",
      "     namespace: resource-tuning",
      "   spec:",
      "     limits:",
      "     - default:",
      "         cpu: \"200m\"",
      "         memory: \"256Mi\"",
      "       defaultRequest:",
      "         cpu: \"100m\"",
      "         memory: \"128Mi\"",
      "       type: Container",
      "   EOF",
      "2. Create ResourceQuota:",
      "   kubectl apply -f - <<EOF",
      "   apiVersion: v1",
      "   kind: ResourceQuota",
      "   metadata:",
      "     name: namespace-quota",
      "     namespace: resource-tuning",
      "   spec:",
      "     hard:",
      "       requests.cpu: \"2\"",
      "       requests.memory: \"4Gi\"",
      "       limits.cpu: \"4\"",
      "       limits.memory: \"8Gi\"",
      "       pods: \"10\"",
      "   EOF",
      "3. Deploy Guaranteed QoS pod (requests = limits):",
      "   kubectl apply -f - <<EOF",
      "   apiVersion: v1",
      "   kind: Pod",
      "   metadata:",
      "     name: guaranteed-app",
      "     namespace: resource-tuning",
      "   spec:",
      "     containers:",
      "     - name: app",
      "       image: nginx:alpine",
      "       resources:",
      "         requests:",
      "           cpu: \"500m\"",
      "           memory: \"1Gi\"",
      "         limits:",
      "           cpu: \"500m\"",
      "           memory: \"1Gi\"",
      "   EOF",
      "4. Deploy Burstable QoS pod (requests < limits):",
      "   kubectl apply -f - <<EOF",
      "   apiVersion: v1",
      "   kind: Pod",
      "   metadata:",
      "     name: burstable-app",
      "     namespace: resource-tuning",
      "   spec:",
      "     containers:",
      "     - name: app",
      "       image: nginx:alpine",
      "       resources:",
      "         requests:",
      "           cpu: \"200m\"",
      "           memory: \"512Mi\"",
      "         limits:",
      "           cpu: \"800m\"",
      "           memory: \"2Gi\"",
      "   EOF",
      "5. Deploy BestEffort QoS pod (no requests/limits):",
      "   kubectl apply -f - <<EOF",
      "   apiVersion: v1",
      "   kind: Pod",
      "   metadata:",
      "     name: besteffort-app",
      "     namespace: resource-tuning",
      "   spec:",
      "     containers:",
      "     - name: app",
      "       image: nginx:alpine",
      "   EOF",
      "6. Verify QoS classes and resource allocations:",
      "   kubectl get pods -n resource-tuning -o custom-columns=NAME:.metadata.name,QOS:.status.qosClass,PHASE:.status.phase",
      "   kubectl top pods -n resource-tuning",
      "   kubectl describe resourcequota namespace-quota -n resource-tuning"
    ]
  },
  "validations": [
    {
      "command": "kubectl get pod guaranteed-app -n resource-tuning -o jsonpath='{.status.qosClass}'",
      "expected": "Guaranteed",
      "points": 3,
      "description": "Guaranteed QoS pod has correct class"
    },
    {
      "command": "kubectl get pod burstable-app -n resource-tuning -o jsonpath='{.status.qosClass}'",
      "expected": "Burstable",
      "points": 3,
      "description": "Burstable QoS pod has correct class"
    },
    {
      "command": "kubectl get pod besteffort-app -n resource-tuning -o jsonpath='{.status.qosClass}'",
      "expected": "BestEffort",
      "points": 3,
      "description": "BestEffort QoS pod has correct class"
    },
    {
      "command": "kubectl get pod guaranteed-app -n resource-tuning -o jsonpath='{.spec.containers[0].resources.requests.cpu}'",
      "expected": "500m",
      "points": 2,
      "description": "Guaranteed pod has CPU requests set"
    },
    {
      "command": "kubectl get pod guaranteed-app -n resource-tuning -o jsonpath='{.spec.containers[0].resources.limits.cpu}'",
      "expected": "500m",
      "points": 2,
      "description": "Guaranteed pod has matching CPU limits"
    },
    {
      "command": "kubectl top pod -n resource-tuning | grep guaranteed-app",
      "expected": "resource-usage",
      "points": 1,
      "description": "Pod resource usage is visible"
    }
  ]
}