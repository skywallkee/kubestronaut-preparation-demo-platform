{
  "id": "ckad-a-061",
  "title": "End-to-End Observability Pipeline",
  "description": "Design a complete ||end-to-end observability|| pipeline that integrates logs, metrics, traces, and alerts into a unified monitoring system. Create applications that generate telemetry data across all observability pillars, implement correlation between different data types (logs with traces, metrics with events), and build comprehensive dashboards that provide full system visibility. Include scenarios with cross-service dependency mapping, incident response automation, and observability-driven development practices.",
  "points": 15,
  "timeLimit": 30,
  "category": "Observability",
  "tags": ["observability", "telemetry", "correlation", "dashboards", "incident-response", "o11y", "advanced"],
  "infrastructure": {
    "namespaces": ["observability-pipeline"],
    "resources": ["Deployment", "Service", "ConfigMap", "ServiceMonitor"],
    "prerequisites": ["Complete observability stack (Prometheus, Jaeger, ELK/Loki)"]
  },
  "solution": {
    "steps": [
      "# Create observability-pipeline namespace\nkubectl create namespace observability-pipeline",

      "# Create observability configuration\nkubectl apply -f - <<EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: observability-config\n  namespace: observability-pipeline\ndata:\n  correlation.yaml: |\n    correlation_enabled: true\n    trace_correlation:\n      header_name: \"X-Trace-ID\"\n      log_format: \"json\"\n    metrics_correlation:\n      business_events: true\n      custom_dimensions: true\n    unified_telemetry:\n      enabled: true\n      retention_days: 7\nEOF",

      "# Deploy frontend microservice with full telemetry\nkubectl apply -f - <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\n  namespace: observability-pipeline\n  labels:\n    app: frontend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: frontend\n        image: python:3.9-slim\n        ports:\n        - containerPort: 8080\n        env:\n        - name: SERVICE_NAME\n          value: \"frontend\"\n        - name: TELEMETRY_ENABLED\n          value: \"true\"\n        command:\n        - /bin/sh\n        - -c\n        - |\n          pip install flask requests uuid4\n          \n          cat > /app/main.py << 'SCRIPT'\n          import flask\n          import requests\n          import uuid\n          import time\n          import json\n          import logging\n          import random\n          from datetime import datetime\n          \n          app = flask.Flask(__name__)\n          \n          # Configure structured logging with trace correlation\n          logging.basicConfig(\n              level=logging.INFO,\n              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n          )\n          logger = logging.getLogger(__name__)\n          \n          # Business transaction counter\n          business_transactions = 0\n          \n          @app.route('/api/process')\n          def process_request():\n              global business_transactions\n              \n              # Generate trace ID for request correlation\n              trace_id = str(uuid.uuid4())\n              span_id = str(uuid.uuid4())[:8]\n              \n              # Log with trace correlation\n              log_entry = {\n                  'timestamp': datetime.now().isoformat(),\n                  'service': 'frontend',\n                  'trace_id': trace_id,\n                  'span_id': span_id,\n                  'message': 'Processing frontend request',\n                  'level': 'INFO'\n              }\n              logger.info(json.dumps(log_entry))\n              \n              # Call backend service with trace context\n              try:\n                  response = requests.get(\n                      'http://backend:8081/process',\n                      headers={'X-Trace-ID': trace_id, 'X-Span-ID': span_id},\n                      timeout=5\n                  )\n                  \n                  # Business event logging\n                  business_transactions += 1\n                  business_log = {\n                      'timestamp': datetime.now().isoformat(),\n                      'service': 'frontend',\n                      'trace_id': trace_id,\n                      'event_type': 'business_transaction',\n                      'transaction_id': business_transactions,\n                      'backend_status': response.status_code\n                  }\n                  logger.info(json.dumps(business_log))\n                  \n              except Exception as e:\n                  error_log = {\n                      'timestamp': datetime.now().isoformat(),\n                      'service': 'frontend',\n                      'trace_id': trace_id,\n                      'level': 'ERROR',\n                      'error': str(e)\n                  }\n                  logger.error(json.dumps(error_log))\n              \n              return flask.jsonify({\n                  'trace_id': trace_id,\n                  'status': 'processed',\n                  'service': 'frontend',\n                  'timestamp': datetime.now().isoformat()\n              })\n          \n          @app.route('/telemetry')\n          def get_telemetry_info():\n              return flask.jsonify({\n                  'instrumentation': 'full',\n                  'trace_correlation': True,\n                  'metrics_enabled': True,\n                  'log_correlation': True,\n                  'business_transactions': business_transactions\n              })\n          \n          @app.route('/metrics')\n          def metrics():\n              return f'''# HELP business_transaction_total Total business transactions\n# TYPE business_transaction_total counter\nbusiness_transaction_total{{service=\"frontend\"}} {business_transactions}\n\n# HELP http_requests_total Total HTTP requests\n# TYPE http_requests_total counter\nhttp_requests_total{{service=\"frontend\",method=\"GET\"}} {random.randint(100, 1000)}\n'''\n          \n          if __name__ == '__main__':\n              app.run(host='0.0.0.0', port=8080)\n          SCRIPT\n          \n          cd /app && python main.py\nEOF",

      "# Deploy backend microservice with span propagation\nkubectl apply -f - <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: backend\n  namespace: observability-pipeline\n  labels:\n    app: backend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: backend\n  template:\n    metadata:\n      labels:\n        app: backend\n    spec:\n      containers:\n      - name: backend\n        image: python:3.9-slim\n        ports:\n        - containerPort: 8081\n        env:\n        - name: SERVICE_NAME\n          value: \"backend\"\n        command:\n        - /bin/sh\n        - -c\n        - |\n          pip install flask requests\n          \n          cat > /app/main.py << 'SCRIPT'\n          import flask\n          import requests\n          import json\n          import logging\n          import time\n          import random\n          from datetime import datetime\n          \n          app = flask.Flask(__name__)\n          \n          logging.basicConfig(\n              level=logging.INFO,\n              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n          )\n          logger = logging.getLogger(__name__)\n          \n          processed_requests = 0\n          \n          @app.route('/process')\n          def process_backend():\n              global processed_requests\n              \n              # Extract trace context from headers\n              trace_id = flask.request.headers.get('X-Trace-ID', 'no-trace')\n              span_id = flask.request.headers.get('X-Span-ID', 'no-span')\n              \n              # Create new span for backend processing\n              backend_span_id = str(random.randint(10000000, 99999999))\n              \n              # Log with trace correlation\n              log_entry = {\n                  'timestamp': datetime.now().isoformat(),\n                  'service': 'backend',\n                  'trace_id': trace_id,\n                  'span_id': backend_span_id,\n                  'parent_span_id': span_id,\n                  'message': 'Processing backend request',\n                  'level': 'INFO'\n              }\n              logger.info(json.dumps(log_entry))\n              \n              # Simulate processing time\n              time.sleep(random.uniform(0.01, 0.1))\n              \n              # Call database service\n              try:\n                  db_response = requests.get(\n                      'http://database:8082/query',\n                      headers={'X-Trace-ID': trace_id, 'X-Parent-Span-ID': backend_span_id},\n                      timeout=3\n                  )\n                  \n                  processed_requests += 1\n                  \n                  success_log = {\n                      'timestamp': datetime.now().isoformat(),\n                      'service': 'backend',\n                      'trace_id': trace_id,\n                      'span_id': backend_span_id,\n                      'message': 'Backend processing completed',\n                      'database_status': db_response.status_code,\n                      'processed_count': processed_requests\n                  }\n                  logger.info(json.dumps(success_log))\n                  \n              except Exception as e:\n                  error_log = {\n                      'timestamp': datetime.now().isoformat(),\n                      'service': 'backend',\n                      'trace_id': trace_id,\n                      'span_id': backend_span_id,\n                      'level': 'ERROR',\n                      'error': str(e)\n                  }\n                  logger.error(json.dumps(error_log))\n              \n              return flask.jsonify({\n                  'status': 'processed',\n                  'service': 'backend',\n                  'trace_id': trace_id,\n                  'span_id': backend_span_id\n              })\n          \n          if __name__ == '__main__':\n              app.run(host='0.0.0.0', port=8081)\n          SCRIPT\n          \n          cd /app && python main.py\nEOF",

      "# Deploy database microservice with telemetry\nkubectl apply -f - <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: database\n  namespace: observability-pipeline\n  labels:\n    app: database\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: database\n  template:\n    metadata:\n      labels:\n        app: database\n    spec:\n      containers:\n      - name: database\n        image: python:3.9-slim\n        ports:\n        - containerPort: 8082\n        env:\n        - name: SERVICE_NAME\n          value: \"database\"\n        command:\n        - /bin/sh\n        - -c\n        - |\n          pip install flask\n          \n          cat > /app/main.py << 'SCRIPT'\n          import flask\n          import json\n          import logging\n          import time\n          import random\n          from datetime import datetime\n          \n          app = flask.Flask(__name__)\n          \n          logging.basicConfig(\n              level=logging.INFO,\n              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n          )\n          logger = logging.getLogger(__name__)\n          \n          query_count = 0\n          \n          @app.route('/query')\n          def execute_query():\n              global query_count\n              \n              trace_id = flask.request.headers.get('X-Trace-ID', 'no-trace')\n              parent_span_id = flask.request.headers.get('X-Parent-Span-ID', 'no-parent')\n              db_span_id = str(random.randint(10000000, 99999999))\n              \n              # Log database operation with trace correlation\n              log_entry = {\n                  'timestamp': datetime.now().isoformat(),\n                  'service': 'database',\n                  'trace_id': trace_id,\n                  'span_id': db_span_id,\n                  'parent_span_id': parent_span_id,\n                  'message': 'Executing database query',\n                  'operation': 'SELECT',\n                  'level': 'INFO'\n              }\n              logger.info(json.dumps(log_entry))\n              \n              # Simulate query execution\n              time.sleep(random.uniform(0.005, 0.05))\n              query_count += 1\n              \n              completion_log = {\n                  'timestamp': datetime.now().isoformat(),\n                  'service': 'database',\n                  'trace_id': trace_id,\n                  'span_id': db_span_id,\n                  'message': 'Database query completed',\n                  'rows_returned': random.randint(1, 100),\n                  'query_number': query_count\n              }\n              logger.info(json.dumps(completion_log))\n              \n              return flask.jsonify({\n                  'status': 'success',\n                  'service': 'database',\n                  'trace_id': trace_id,\n                  'span_id': db_span_id,\n                  'rows': random.randint(1, 100)\n              })\n          \n          @app.route('/health')\n          def health():\n              return flask.jsonify({\n                  'telemetry_health': 'healthy',\n                  'service': 'database',\n                  'queries_executed': query_count\n              })\n          \n          if __name__ == '__main__':\n              app.run(host='0.0.0.0', port=8082)\n          SCRIPT\n          \n          cd /app && python main.py\nEOF",

      "# Create services for all microservices\nkubectl apply -f - <<EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend\n  namespace: observability-pipeline\n  labels:\n    app: frontend\nspec:\n  selector:\n    app: frontend\n  ports:\n  - port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: backend\n  namespace: observability-pipeline\n  labels:\n    app: backend\nspec:\n  selector:\n    app: backend\n  ports:\n  - port: 8081\n    targetPort: 8081\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: database\n  namespace: observability-pipeline\n  labels:\n    app: database\nspec:\n  selector:\n    app: database\n  ports:\n  - port: 8082\n    targetPort: 8082\nEOF",

      "# Create ServiceMonitor for metrics collection\nkubectl apply -f - <<EOF\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: observability-pipeline-monitor\n  namespace: observability-pipeline\n  labels:\n    monitoring: enabled\nspec:\n  selector:\n    matchLabels:\n      app: frontend\n  endpoints:\n  - port: http\n    path: /metrics\n    interval: 30s\nEOF",

      "# Wait for all deployments to be ready\nkubectl wait --for=condition=available --timeout=300s deployment/frontend -n observability-pipeline\nkubectl wait --for=condition=available --timeout=300s deployment/backend -n observability-pipeline\nkubectl wait --for=condition=available --timeout=300s deployment/database -n observability-pipeline",

      "# Generate telemetry data by making requests\nkubectl run telemetry-test --image=busybox --rm -it --restart=Never -n observability-pipeline -- sh -c 'for i in $(seq 1 15); do wget -qO- http://frontend:8080/api/process; echo; sleep 1; done'",

      "# Test telemetry endpoints\nkubectl exec -n observability-pipeline deploy/frontend -- curl -s localhost:8080/telemetry\nkubectl exec -n observability-pipeline deploy/database -- curl -s localhost:8082/health"
    ]
  },
  "validations": [
    {
      "command": "kubectl get deployment -n observability-pipeline | grep -c 'frontend\\|backend\\|database'",
      "expected": "3",
      "points": 2,
      "description": "All microservices are deployed"
    },
    {
      "command": "kubectl exec -n observability-pipeline deploy/frontend -- curl -s localhost:8080/telemetry | jq .instrumentation",
      "expected": "full",
      "points": 3,
      "description": "Services have full telemetry instrumentation"
    },
    {
      "command": "kubectl logs -n observability-pipeline deploy/backend | grep -c 'trace_id.*span_id'",
      "expected": "10",
      "points": 3,
      "description": "Logs include trace correlation identifiers"
    },
    {
      "command": "kubectl exec -n observability-pipeline deploy/frontend -- curl -s localhost:8080/metrics | grep 'business_transaction_total'",
      "expected": "business-metric",
      "points": 3,
      "description": "Metrics include business-level indicators"
    },
    {
      "command": "kubectl get configmap observability-config -n observability-pipeline -o jsonpath='{.data.correlation\\.yaml}' | grep correlation_enabled",
      "expected": "true",
      "points": 2,
      "description": "Observability correlation is enabled"
    },
    {
      "command": "kubectl exec -n observability-pipeline deploy/database -- curl -s localhost:8082/health | jq .telemetry_health",
      "expected": "healthy",
      "points": 2,
      "description": "All observability components are healthy"
    }
  ]
}